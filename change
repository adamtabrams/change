#!/bin/sh

change_file="CHANGELOG.md"
xdg_data_home=${XDG_DATA_HOME:-$HOME/.local/share}
auth_dir="$xdg_data_home/change/"
auth_file="$auth_dir/auth"
nl="
"

usage() {
    echo "usage: change [COMMAND]"
    echo ""
    echo "change"
    echo "    updates an existing $change_file"
    echo ""
    echo "change tag"
    echo "    tags the latest commit with the lastest version"
    echo "    in $change_file and pushes that tag to origin"
    echo ""
    echo "change init"
    echo "    creates a $change_file with the first version"
    echo ""
    echo "change auth"
    echo "    prompts you for a person access token that"
    echo "    can be used for posting releases"
    echo ""
    echo "change post"
    echo "    posts a GitHub release for the latest version"
    echo "    in $change_file"
    echo ""
    echo "change all"
    echo "    runs change, then opens $change_file in \$EDITOR,"
    echo "    amends $change_file to your last commit, runs"
    echo "    change tag, and then runs change post."
}

get_version() {
    echo "$1" | sed "s|^[^[:digit:]]*\([[:digit:].]*\).*|\1|"
}

get_ver_name_date() {
    date=$(git log -1 --pretty=format:"%ci" "$1" 2> /dev/null | cut -d " " -f 1)
    [ "$date" ] && { echo "$date"; return; }
    date +%F
}

format_commits() {
    list="$1"

    dep=$(echo "$list" | grep ".!: ")
    list=$(echo "$list" | grep -v ".!: ")

    feat=$(echo "$list" | grep -i "^feat: \|^feat(.*): ")
    list=$(echo "$list" | grep -iv "^feat: \|^feat(.*): ")

    fix=$(echo "$list" | grep -i "^fix: \|^fix(.*): ")
    list=$(echo "$list" | grep -iv "^fix: \|^fix(.*): ")

    [ "$dep" ] && echo "### Deprecated" && fmt_subject "$dep" && echo ""
    [ "$feat" ] && echo "### Added" && fmt_subject "$feat" && echo ""
    [ "$fix" ] && echo "### Fixed" && fmt_subject "$fix" && echo ""
    [ "$list" ] && echo "### Changed" && fmt_subject "$list" && echo ""
}

fmt_subject() {
    rm_prefix=$(echo "$1" | sed -e "s|^.*(\(.*\)): \(.*$\)|\2 for \1|" -e "s|^.*: \(.*$\)|\1|")

    IFS="$nl"
    for subject in $rm_prefix; do
        first_char=$(echo "$subject" | cut -c 1 | tr "[:lower:]" "[:upper:]")

        echo "$subject" | sed -e "s|^.\(.*$\)|$first_char\1|" -e "s|\(.*\)|- \1.|"
    done
}

get_needed_log_ver_names() {
    latest_git_ver_name=$1
    latest_log_ver_name=$2

    tags=$(git tag --list "[[:digit:]]*\.[[:digit:]]*" --sort="-v:refname")

    ! echo "$tags" | grep -q "$latest_log_ver_name" && return 0
    echo "$tags" | sed -n "/$latest_log_ver_name/!p;//q" | sed '1!G;h;$!d'

    latest_changes=$(git log --pretty=format:"%B" "$latest_git_ver_name..")
    [ ! "$latest_changes" ] && return

    get_new_version_name "$latest_changes" "$latest_git_ver_name"
}

get_new_version_name() {
    latest_changes=$1
    latest_git_ver_name=$2

    echo "$latest_changes" | grep -q ".!: \|^BREAKING.CHANGE: " &&
        increment_major "$latest_git_ver_name" && return

    echo "$latest_changes" | grep -iq "^feat: \|^feat(.*): " &&
        increment_minor "$latest_git_ver_name" && return

    echo "$latest_changes" | grep -iq "^fix: \|^fix(.*): " &&
        increment_patch "$latest_git_ver_name" && return
}

increment_major() {
    cur_major=$(echo "$1" | sed "s|^[^[:digit:]]*\([[:digit:]]*\)\..*$|\1|")
    echo "$1" | sed "s|\.[[:digit:]]*|.0|g" |
        sed "s|\(^[^[:digit:]]*\)[[:digit:]]*\(\..*$\)|\1$(( cur_major + 1 ))\2|"
}

increment_minor() {
    cur_minor=$(echo "$1" | sed "s|^.*\.\([[:digit:]]*\)\..*$|\1|")
    echo "$1" | sed "s|\.[[:digit:]]*|.0|g" |
        sed "s|\(^.*\.\)[[:digit:]]*\(\..*$\)|\1$(( cur_minor + 1 ))\2|"
}

increment_patch() {
    cur_patch=$(echo "$1" | sed "s|^.*\.\([[:digit:]]*\).*$|\1|")
    echo "$1" | sed "s|\(^.*\.\)[[:digit:]]*\(.*$\)|\1$(( cur_patch + 1 ))\2|"
}

update_diffs() {
    latest_git_ver_name=$1
    latest_log_ver_name=$2
    needed_log_ver_name=$3

    latest_log_ver=$(get_version "$latest_log_ver_name")
    needed_log_ver=$(get_version "$needed_log_ver_name")
    new_commits=$(get_commits_between "$latest_git_ver_name" \
        "$latest_log_ver_name" "$needed_log_ver_name")

    new_section="## [$needed_log_ver] - $(get_ver_name_date "$needed_log_ver_name")\\
$(format_commits "$new_commits" | sed -e "s|\([&\\]\)|\\\\\1|g" -e "s|$|\\\\|")"

    sed -i "" -e "s|\(^## \[$latest_log_ver\] -.*$\)|$new_section$nl\1|" $change_file
}

update_links() {
    latest_log_ver_name=$1
    needed_log_ver_name=$2

    latest_log_ver=$(get_version "$latest_log_ver_name")
    needed_log_ver=$(get_version "$needed_log_ver_name")
    repo_url=$(git config --get remote.origin.url | sed "s|\(.*\)\.git|\1|")

    new_link="[$needed_log_ver]: $repo_url/compare/$latest_log_ver_name...$needed_log_ver_name"

    sed -i "" -e "s|\(^\[$latest_log_ver\]:.*$\)|$new_link\\$nl\1|" "$change_file"

    reg="s|\(^\[Unreleased\]:.*\)/$latest_log_ver_name\.\.\.HEAD$|\1/$needed_log_ver_name...HEAD|"
    sed -i "" -e "$reg" "$change_file"
}

get_commits_between() {
    latest_git_ver_name=$1
    latest_log_ver_name=$2
    needed_log_ver_name=$3

    highest_ver_name=$(printf "%s\n%s\n" "$latest_git_ver_name" "$needed_log_ver_name" |
        sort -Vr | head -1)

    [ "$latest_git_ver_name" = "$highest_ver_name" ] &&
        git log --pretty=format:"%s" "$latest_log_ver_name..$needed_log_ver_name" && return

    git log --pretty=format:"%s" "$latest_log_ver_name.."
}

startup_checks() {
    ! git rev-parse 2> /dev/null && { echo "you're no in a git repo" >&2; return 1; }
    [ ! -e "$change_file" ] && { echo "couldn't find $change_file" >&2; return 1; }
    return 0
}

make_and_push_tag() {
    ! startup_checks && return 1

    latest_log_ver_name=$(sed -n "s|^\[Unreleased\]:.*/\(.*\)\.\.\.HEAD$|\1|p" $change_file)

    git tag "$latest_log_ver_name" &&
        git push origin "$latest_log_ver_name" &&
        echo "tagged latest commit as $latest_log_ver_name" &&
        echo "and pushed tag to origin"
}

auth() {
    echo "enter a personal access token"
    printf "token: "
    read -r token

    [ ! "$token" ] && { echo "invalid token" >&2; return 1; }
    [ ! -d "$auth_dir" ] && mkdir -p "$auth_dir"
    echo "$token" | base64 > "$auth_file" && echo "done"
}

post_release() {
    ! startup_checks && return 1
    [ ! -e "$auth_file" ] && { echo "you need to save a token with the auth" >&2; return 1; }

    auth_token=$(base64 --decode < "$auth_file")
    latest_log_ver_name=$(sed -n "s|^\[Unreleased\]:.*/\(.*\)\.\.\.HEAD$|\1|p" $change_file)
    latest_log_ver=$(get_version "$latest_log_ver_name")

    repo_url=$(git config --get remote.origin.url |
        sed -e "s|\(.*\)\.git|\1|" -e "s|\(^.*\)\(github.com\)|\1api.\2/repos|")

    diff=$(sed -n "/^## \[$latest_log_ver\] -.*/,/^## \[.*\] -.*/P" $change_file | sed "\$d")
    link=$(grep "^\[$latest_log_ver\]: .*" $change_file)
    body=$(echo "$diff$nl$nl$link" | sed -e "s|\([\"\\]\)|\\\\\1|g" -e "s|$|\\\\|" | tr '\n' 'n')

    curl -X POST "$repo_url/releases" \
        -H "Authorization: token $auth_token" \
        -H "Content-Type: application/json" \
        -d "{\"tag_name\": \"$latest_log_ver_name\", \"name\": \"$latest_log_ver_name\", \"body\": \"$body\" }"
}

init() {
    ! git rev-parse 2> /dev/null && { echo "you're no in a git repo" >&2; return 1; }

    first_ver_name=$(git tag --list "[[:digit:]]*\.[[:digit:]]*" --sort="v:refname" | head -1)
    first_ver=$(get_version "$first_ver_name")
    first_commits=$(git log --pretty=format:"%s" "$first_ver_name")
    repo_url=$(git config --get remote.origin.url | sed "s|\(.*\)\.git|\1|")

    [ -e "$change_file" ] && { echo "$change_file already exists" >&2; return 1; }
    [ ! "$first_ver" ] && { echo "couldn't get first version" >&2; return 2; }

    echo "# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [$first_ver] - $(get_ver_name_date "$first_ver_name")
$(format_commits "$first_commits")

[Unreleased]: $repo_url/compare/$first_ver_name...HEAD
[$first_ver]: $repo_url/releases/tag/$first_ver_name" > "$change_file"

    [ ! -e "$change_file" ] &&
        echo "something when wrong while creating $change_file" >&2 && return 1
    echo "created $change_file" >&2
}

run_all() {
    save_file=$(cat $change_file)
    ! modify_file  && return 1
    first_change=$(stat -qf "%Sc" $change_file)
    ${EDITOR:-vi} $change_file
    last_change=$(stat -qf "%Sc" $change_file)
    [ "$first_change" = "$last_change" ] &&
        echo "cancelling because no manual edits were made to $change_file" >&2 &&
        echo "$save_file" > $change_file &&
        return 1
    git add $change_file && git commit --amend --no-edit && make_and_push_tag && post_release
}

modify_file() {
    ! startup_checks && return 1

    latest_git_ver_name=$(git tag --list "[[:digit:]]*\.[[:digit:]]*" --sort="-v:refname" | head -1)
    latest_log_ver_name=$(sed -n "s|^\[Unreleased\]:.*/\(.*\)\.\.\.HEAD$|\1|p" $change_file)
    needed_log_ver_names=$(get_needed_log_ver_names "$latest_git_ver_name" "$latest_log_ver_name")

    [ ! "$needed_log_ver_names" ] && { echo "no new versions to add" >&2; return 1; }

    IFS="$nl"
    for needed_log_ver_name in $needed_log_ver_names; do
        update_diffs "$latest_git_ver_name" "$latest_log_ver_name" "$needed_log_ver_name"
        update_links "$latest_log_ver_name" "$needed_log_ver_name"
        echo "added $needed_log_ver_name to $change_file"

        latest_log_ver_name="$needed_log_ver_name"
    done
}

[ "$2"            ] && { echo "change currently accepts only one argument" >&2; exit 1; }
[ ! "$1"          ] && { modify_file;       exit; }
[ "$1" = "init"   ] && { init;              exit; }
[ "$1" = "tag"    ] && { make_and_push_tag; exit; }
[ "$1" = "auth"   ] && { auth;              exit; }
[ "$1" = "post"   ] && { post_release;      exit; }
[ "$1" = "all"    ] && { run_all;           exit; }
[ "$1" = "-h"     ] && { usage;             exit; }
[ "$1" = "help"   ] && { usage;             exit; }
[ "$1" = "--help" ] && { usage;             exit; }
[ "$1"            ] && { printf "couldn't recognize argument\n\n" >&2; usage >&2; exit 1; }
