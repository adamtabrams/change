#!/bin/sh

change_file="CHANGELOG.md"
xdg_data_home=${XDG_DATA_HOME:-$HOME/.local/share}
auth_dir="$xdg_data_home/change/"
auth_file="$auth_dir/auth"
change_version="0.12.0"
nl="
"

usage() {
    echo "usage: change [COMMAND]"
    echo
    echo "change"
    echo "    updates an existing $change_file"
    echo
    echo "change tag [-p]"
    echo "    tags the latest local commit with the lastest $change_file version"
    echo "    optional: -p also pushes that tag to origin"
    echo
    echo "change post [--dry-run]"
    echo "    posts a GitHub release for the latest version in $change_file"
    echo "    optional: --dry-run prints url, version, and body without sending"
    echo
    echo "change auth [TOKEN]"
    echo "    prompts you for a personal access token for posting releases"
    echo "    optional: give token as argument instead of with prompt"
    echo
    echo "change init"
    echo "    creates a $change_file with the first version"
    echo
    echo "change all"
    echo "    runs change, then opens $change_file in \$EDITOR"
    echo "    commits and pushes the $change_file to origin"
    echo "    runs change tag -p and then runs change post"
    echo
    echo "change --version"
    echo "    prints which version of the change tool is being used"
}

get_versions() {
    reverse=${1:-v} # sending arg "-v" reverses the list
    git tag --list "[0-9]*\.[0-9]*.*" "v[0-9]*\.[0-9]*.*" --sort="${reverse}:refname"
}

rm_ver_prefix() {
    echo "$1" | sed "s|^[^0-9]*\([0-9.]*.*\)|\1|"
}

rm_ver_suffix() {
    sed "s|\(^[^0-9]*[0-9.]*\).*|\1|"
}

get_ver_name_date() {
    date=$(git log -1 --pretty=format:"%ci" "$1" 2> /dev/null | cut -d " " -f 1)
    [ "$date" ] && { echo "$date"; return; }
    date +%F
}

fmt_subject() {
    rm_prefix=$(echo "$1" | sed -e "s|^[^ ]*(\(.*\))!*: \(.*$\)|\2 for \1|" -e "s|^[^ ]*: \(.*$\)|\1|")

    IFS="$nl"
    for subject in $rm_prefix; do
        first_char=$(echo "$subject" | cut -c 1 | tr "[:lower:]" "[:upper:]")

        echo "$subject" | sed -e "s|^.\(.*$\)|$first_char\1|" -e "s|\(.*\)|- \1.|"
    done
}

format_commits() {
    list="$1"

    dep=$(echo "$list" | grep "^[^ ]*!: ")
    list=$(echo "$list" | grep -v "^[^ ]*!: ")

    feat=$(echo "$list" | grep -i "^feat: \|^feat(.*): ")
    list=$(echo "$list" | grep -iv "^feat: \|^feat(.*): ")

    fix=$(echo "$list" | grep -i "^fix: \|^fix(.*): ")
    list=$(echo "$list" | grep -iv "^fix: \|^fix(.*): ")

    [ "$dep" ] && echo "### Deprecated" && fmt_subject "$dep" && echo ""
    [ "$feat" ] && echo "### Added" && fmt_subject "$feat" && echo ""
    [ "$fix" ] && echo "### Fixed" && fmt_subject "$fix" && echo ""
    [ "$list" ] && echo "### Changed" && fmt_subject "$list" && echo ""
}

increment_major() {
    cur_major=$(echo "$1" | sed "s|^[^0-9]*\([0-9]*\)\..*$|\1|")
    echo "$1" | sed "s|\.[0-9]*|.0|g" |
        sed "s|\(^[^0-9]*\)[0-9]*\(\..*$\)|\1$(( cur_major + 1 ))\2|"
}

increment_minor() {
    cur_minor=$(echo "$1" | sed "s|^.*\.\([0-9]*\)\..*$|\1|")
    echo "$1" | sed "s|\.[0-9]*|.0|g" |
        sed "s|\(^.*\.\)[0-9]*\(\..*$\)|\1$(( cur_minor + 1 ))\2|"
}

increment_patch() {
    cur_patch=$(echo "$1" | sed "s|^.*\.\([0-9]*\).*$|\1|")
    echo "$1" | sed "s|\(^.*\.\)[0-9]*\(.*$\)|\1$(( cur_patch + 1 ))\2|"
}

get_new_version_name() {
    latest_changes=$1
    latest_git_ver_name=$2

    echo "$latest_changes" | grep -q ".!: \|^BREAKING.CHANGE: " &&
        increment_major "$latest_git_ver_name" && return

    echo "$latest_changes" | grep -iq "^feat: \|^feat(.*): " &&
        increment_minor "$latest_git_ver_name" && return

    echo "$latest_changes" | grep -iq "^fix: \|^fix(.*): " &&
        increment_patch "$latest_git_ver_name" && return
}

get_needed_log_ver_names() {
    latest_git_ver_name=$1
    latest_log_ver_name=$2

    tags=$(get_versions -v)

    ! echo "$tags" | grep -q "$latest_log_ver_name" && return 0
    echo "$tags" | sed -n "/$latest_log_ver_name/!p;//q" | sed '1!G;h;$!d'

    latest_changes=$(git log --pretty=format:"%B" "$latest_git_ver_name..")
    [ ! "$latest_changes" ] && return

    get_new_version_name "$latest_changes" "$latest_git_ver_name" | rm_ver_suffix
}

update_diffs() {
    latest_git_ver_name=$1
    latest_log_ver_name=$2
    needed_log_ver_name=$3

    latest_log_ver=$(rm_ver_prefix "$latest_log_ver_name")
    needed_log_ver=$(rm_ver_prefix "$needed_log_ver_name")
    new_commits=$(get_commits_between "$latest_git_ver_name" \
        "$latest_log_ver_name" "$needed_log_ver_name")

    new_section="## [$needed_log_ver] - $(get_ver_name_date "$needed_log_ver_name")\\
$(format_commits "$new_commits" | sed -e "s|\([&\\]\)|\\\\\1|g" -e "s|$|\\\\|")"

    sed -i.backup "s|\(^## \[$latest_log_ver\] -.*$\)|$new_section$nl\1|" $change_file &&
        rm "${change_file}.backup"
}

update_links() {
    latest_log_ver_name=$1
    needed_log_ver_name=$2

    latest_log_ver=$(rm_ver_prefix "$latest_log_ver_name")
    needed_log_ver=$(rm_ver_prefix "$needed_log_ver_name")
    repo_url=$(git config --get remote.origin.url | sed "s|\(.*\)\.git|\1|")

    new_link="[$needed_log_ver]: $repo_url/compare/$latest_log_ver_name...$needed_log_ver_name"

    sed -i.backup "s|\(^\[$latest_log_ver\]:.*$\)|$new_link\\$nl\1|" "$change_file" &&
        rm "${change_file}.backup"

    reg="s|\(^\[Unreleased\]:.*\)/$latest_log_ver_name\.\.\.HEAD$|\1/$needed_log_ver_name...HEAD|"
    sed -i.backup "$reg" "$change_file" &&
        rm "${change_file}.backup"
}

get_commits_between() {
    latest_git_ver_name=$1
    latest_log_ver_name=$2
    needed_log_ver_name=$3

    highest_ver_name=$(printf "%s\n%s\n" "$latest_git_ver_name" "$needed_log_ver_name" |
        sort -Vr | head -1)

    [ "$latest_git_ver_name" = "$highest_ver_name" ] &&
        git log --pretty=format:"%s" "$latest_log_ver_name..$needed_log_ver_name" && return

    git log --pretty=format:"%s" "$latest_log_ver_name.."
}

startup_checks() {
    [ ! -e "$change_file" ] && { echo "couldn't find $change_file" >&2; return 1; }
    [ ! -d .git ] && { echo "the current directory doesn't contain .git" >&2; return 1; }
    ! git config --get remote.origin.url >/dev/null &&
        { echo "remote origin url isn't set for this repo" >&2; return 1; }
    return 0
}

make_and_push_tag() {
    push_tag=$1 # sending arg "-p" pushes
    [ "$push_tag" ] && [ "$push_tag" != -p ] && { echo "$push_tag is not a valid argument" >&2; return 1; }

    ! startup_checks && return 1
    latest_log_ver_name=$(sed -n "s|^\[Unreleased\]:.*/\(.*\)\.\.\.HEAD$|\1|p" $change_file)

    git tag "$latest_log_ver_name" || return 1
    echo "tagged latest commit as $latest_log_ver_name"

    [ "$push_tag" = -p ] &&
        git push --quiet origin "$latest_log_ver_name" &&
        echo "pushed $latest_log_ver_name to origin" &&
        return 0

    echo "to push the latest tag use: git push origin $latest_log_ver_name"
    echo "to push all local tags use: git push origin --tags"
}

auth() {
    token=$1
    [ ! "$token" ] &&
        echo "enter a personal access token" &&
        printf "token: " &&
        read -r token

    [ ! "$token" ] && { echo "invalid token" >&2; return 1; }
    [ ! -d "$auth_dir" ] && mkdir -p "$auth_dir"
    echo "$token" | base64 > "$auth_file" && echo "git auth saved"
}

post_release() {
    dry_run=$1 # sending arg "--dry-run" will print but not send a POST request
    [ "$dry_run" ] && [ "$dry_run" != --dry-run ] && { echo "$dry_run is not a valid argument" >&2; return 1; }

    ! startup_checks && return 1
    [ ! -e "$auth_file" ] && { echo "you need to save a token with the auth" >&2; return 1; }

    auth_token=$(base64 --decode < "$auth_file")
    latest_log_ver_name=$(sed -n "s|^\[Unreleased\]:.*/\(.*\)\.\.\.HEAD$|\1|p" $change_file)
    latest_log_ver=$(rm_ver_prefix "$latest_log_ver_name")

    repo_url=$(git config --get remote.origin.url |
        sed -e "s|\(.*\)\.git|\1|" -e "s|\(^.*\)\(github.com\)|\1api.\2/repos|")

    diff=$(sed -n "/^## \[$latest_log_ver\] -.*/,/^## \[.*\] -.*/P" $change_file | sed "\$d")
    link=$(grep "^\[$latest_log_ver\]: .*" $change_file)
    body=$(echo "$diff$nl$nl$link" | sed -e "s|\([\"\\]\)|\\\\\1|g" -e "s|$|\\\\|" | tr '\n' 'n')

    [ "$dry_run" = --dry-run ] && printf "%s\n%s\n%s\n" "$repo_url" "$latest_log_ver_name" "$body" && return 0

    curl -X POST "$repo_url/releases" \
        -H "Authorization: token $auth_token" \
        -H "Content-Type: application/json" \
        -d "{\"tag_name\": \"$latest_log_ver_name\", \"name\": \"$latest_log_ver_name\", \"body\": \"$body\" }"
}

init() {
    [ ! -d .git ] && { echo "the current directory doesn't contain .git" >&2; return 1; }
    [ -e "$change_file" ] && { echo "$change_file already exists" >&2; return 1; }

    first_ver_name=$(get_versions | head -1)
    [ ! "$first_ver_name" ] && { echo "couldn't find any valid version tags" >&2; return 2; }

    first_ver=$(rm_ver_prefix "$first_ver_name")
    [ ! "$first_ver" ] && { echo "couldn't get first version" >&2; return 2; }

    first_commits=$(git log --pretty=format:"%s" "$first_ver_name")
    [ ! "$first_commits" ] && { echo "couldn't get first commits" >&2; return 2; }

    repo_url=$(git config --get remote.origin.url | sed "s|\(.*\)\.git|\1|")
    [ ! "$repo_url" ] && { echo "remote origin url isn't set for this repo" >&2; return 1; }

    echo "# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [$first_ver] - $(get_ver_name_date "$first_ver_name")
$(format_commits "$first_commits")

[Unreleased]: $repo_url/compare/$first_ver_name...HEAD
[$first_ver]: $repo_url/releases/tag/$first_ver_name" > "$change_file"

    [ ! -e "$change_file" ] &&
        echo "something when wrong while creating $change_file" >&2 && return 1
    echo "created $change_file"
}

run_all() {
    save_file=$(cat $change_file)
    ! modify_file  && return 1
    first_change=$(stat -qf "%Sc" $change_file)
    ${EDITOR:-vi} $change_file
    last_change=$(stat -qf "%Sc" $change_file)
    [ "$first_change" = "$last_change" ] &&
        echo "cancelling because no manual edits were made to $change_file" >&2 &&
        echo "$save_file" > $change_file &&
        return 1
    git add $change_file &&
        git commit --quiet -m "docs: update changelog" &&
        git push --quiet origin &&
        make_and_push_tag -p && post_release
}

modify_file() {
    ! startup_checks && return 1

    latest_git_ver_name=$(get_versions -v | head -1)
    latest_log_ver_name=$(sed -n "s|^\[Unreleased\]:.*/\(.*\)\.\.\.HEAD$|\1|p" $change_file)
    needed_log_ver_names=$(get_needed_log_ver_names "$latest_git_ver_name" "$latest_log_ver_name")

    [ ! "$needed_log_ver_names" ] && { echo "no new versions to add"; return 1; }

    IFS="$nl"
    for needed_log_ver_name in $needed_log_ver_names; do
        update_diffs "$latest_git_ver_name" "$latest_log_ver_name" "$needed_log_ver_name"
        update_links "$latest_log_ver_name" "$needed_log_ver_name"
        echo "added $needed_log_ver_name to $change_file"

        latest_log_ver_name="$needed_log_ver_name"
    done
}

[ ! "$1"             ] && { modify_file;                  exit;   }
[ "$3"               ] && { echo "too many argument" >&2; exit 1; }
[ "$1" = "auth"      ] && { auth "$2";                    exit;   }
[ "$1" = "post"      ] && { post_release "$2";            exit;   }
[ "$1" = "tag"       ] && { make_and_push_tag "$2";       exit;   }
[ "$2"               ] && { echo "too many argument" >&2; exit 1; }
[ "$1" = "init"      ] && { init;                         exit;   }
[ "$1" = "all"       ] && { run_all;                      exit;   }
[ "$1" = "-h"        ] && { usage;                        exit;   }
[ "$1" = "help"      ] && { usage;                        exit;   }
[ "$1" = "--help"    ] && { usage;                        exit;   }
[ "$1" = "--version" ] && { echo "$change_version";       exit;   }
[ "$1" ] && { printf "couldn't recognize argument\n\n" >&2; usage >&2; exit 1; }
